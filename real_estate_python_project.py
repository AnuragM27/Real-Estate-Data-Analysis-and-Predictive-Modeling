# -*- coding: utf-8 -*-
"""Real estate python project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ExYbH9ia5f3S6YcR_REHOrJtuy2_OrXa
"""

# Import necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
from sklearn.linear_model import LinearRegression
from matplotlib.ticker import FuncFormatter
import statsmodels.api as sm
import statsmodels.formula.api as smf
from sklearn.preprocessing import StandardScaler
import scipy.stats as stats

# Load datasets using the raw content URL
apartment_prices = pd.read_csv("https://raw.githubusercontent.com/AnuragM27/Real-Estate-Data-Analysis-and-Predictive-Modeling/b8d5ad0827fd0bec3ae67f49eb82f51517728524/Apartment_prices.csv")
historical_demographic = pd.read_csv("https://raw.githubusercontent.com/AnuragM27/Real-Estate-Data-Analysis-and-Predictive-Modeling/b8d5ad0827fd0bec3ae67f49eb82f51517728524/Historical_demographic.csv", engine="python")
projected_demographic = pd.read_csv("https://raw.githubusercontent.com/AnuragM27/Real-Estate-Data-Analysis-and-Predictive-Modeling/b8d5ad0827fd0bec3ae67f49eb82f51517728524/Projected_demographic.csv", engine="python")

# Display a summary of the loaded datasets
print("Apartment Prices Dataset:")
print(apartment_prices.info())
print("\nHistorical Demographic Dataset:")
print(historical_demographic.info())
print("\nProjected Demographic Dataset:")
print(projected_demographic.info())

# Merge datasets on 'Suburb_name'
merged_data = apartment_prices.merge(historical_demographic, on="Suburb_name") \
                               .merge(projected_demographic, on="Suburb_name")

# List of columns to convert to numeric
columns_to_numeric = [
    "Median_price_2023", "Historical_population_growth", "Historical_median_income",
    "Historical_unemployment_rate", "Historical_priority_growth_area",
    "Projected_population_growth", "Projected_median_income",
    "Projected_unemployment_rate", "Projected_priority_growth_area"
]

# Check summary of the merged data
print("Summary of merged data before conversion:")
print(merged_data.describe(include='all'))

# Convert specified columns to numeric
for column in columns_to_numeric:
    merged_data[column] = pd.to_numeric(merged_data[column], errors='coerce')

# Verify conversion and check for missing values
print("\nSummary of merged data after conversion:")
print(merged_data[columns_to_numeric].info())

# Check for NA values
na_summary = merged_data.isna().sum()
print("NA Summary:")
print(na_summary)

# Handle missing values
mean_income = merged_data['Historical_median_income'].mean(skipna=True)

# Handling wrong values and filling missing values
merged_data['Median_price_2023'] = np.where(
    merged_data['Suburb_name'] == "NORLANE", 309334, merged_data['Median_price_2023']
)
merged_data['Historical_median_income'] = merged_data['Historical_median_income'].fillna(mean_income)

# Check for NA values after handling
na_summary = merged_data.isna().sum()
print("\nNA Summary after handling missing values:")
print(na_summary)

# Function to calculate and print outliers
def calculate_outliers(column):
    stats = {
        "q1": column.quantile(0.25),
        "q3": column.quantile(0.75),
        "iqr": column.quantile(0.75) - column.quantile(0.25),
    }
    stats["lower_bound"] = stats["q1"] - 1.5 * stats["iqr"]
    stats["upper_bound"] = stats["q3"] + 1.5 * stats["iqr"]
    outliers = column[(column < stats["lower_bound"]) | (column > stats["upper_bound"])]
    return outliers

# Calculate and print outliers for each column
columns_to_check = [
    "Median_price_2023", "Historical_median_income", "Historical_population_growth",
    "Historical_unemployment_rate", "Projected_median_income",
    "Projected_population_growth", "Projected_unemployment_rate"
]

for col in columns_to_check:
    outliers = calculate_outliers(merged_data[col])
    print(f"\nOutliers in {col}:")
    print(outliers.values)

# Calculate IQR for Median_price_2023
Q1_price = merged_data['Median_price_2023'].quantile(0.25)
Q3_price = merged_data['Median_price_2023'].quantile(0.75)
IQR_price = Q3_price - Q1_price

# Calculate IQR for Historical_median_income
Q1_income = merged_data['Historical_median_income'].quantile(0.25)
Q3_income = merged_data['Historical_median_income'].quantile(0.75)
IQR_income = Q3_income - Q1_income

# Calculate IQR for Historical_unemployment_rate
Q1_unemployment = merged_data['Historical_unemployment_rate'].quantile(0.25)
Q3_unemployment = merged_data['Historical_unemployment_rate'].quantile(0.75)
IQR_unemployment = Q3_unemployment - Q1_unemployment

# Calculate IQR for Projected_median_income
Q1_proj_income = merged_data['Projected_median_income'].quantile(0.25)
Q3_proj_income = merged_data['Projected_median_income'].quantile(0.75)
IQR_proj_income = Q3_proj_income - Q1_proj_income

# Calculate IQR for Projected_unemployment_rate
Q1_proj_unemployment = merged_data['Projected_unemployment_rate'].quantile(0.25)
Q3_proj_unemployment = merged_data['Projected_unemployment_rate'].quantile(0.75)
IQR_proj_unemployment = Q3_proj_unemployment - Q1_proj_unemployment

# Filter out rows with outliers
merged_data = merged_data[
    (merged_data['Historical_median_income'] > (Q1_income - 1.5 * IQR_income)) &
    (merged_data['Historical_median_income'] < (Q3_income + 1.5 * IQR_income)) &
    (merged_data['Median_price_2023'] > (Q1_price - 1.5 * IQR_price)) &
    (merged_data['Median_price_2023'] < (Q3_price + 1.5 * IQR_price)) &
    (merged_data['Historical_unemployment_rate'] > (Q1_unemployment - 1.5 * IQR_unemployment)) &
    (merged_data['Historical_unemployment_rate'] < (Q3_unemployment + 1.5 * IQR_unemployment)) &
    (merged_data['Projected_median_income'] > (Q1_proj_income - 1.5 * IQR_proj_income)) &
    (merged_data['Projected_median_income'] < (Q3_proj_income + 1.5 * IQR_proj_income)) &
    (merged_data['Projected_unemployment_rate'] > (Q1_proj_unemployment - 1.5 * IQR_proj_unemployment)) &
    (merged_data['Projected_unemployment_rate'] < (Q3_proj_unemployment + 1.5 * IQR_proj_unemployment))
]

# Helper function for formatting large numbers as commas
def format_with_commas(x, pos):
    return f"{int(x):,}"

formatter = FuncFormatter(format_with_commas)

# 1. Distribution of Apartment Prices
plt.figure(figsize=(10, 6))
sns.histplot(merged_data['Median_price_2023'], bins=30, color='yellow', edgecolor='black')
mean_price = merged_data['Median_price_2023'].mean()
plt.axvline(mean_price, color='purple', linestyle='dashed', linewidth=1)
plt.gca().xaxis.set_major_formatter(formatter)
plt.title("Distribution of Apartment Prices")
plt.xlabel("Median Price 2023")
plt.ylabel("Count")
plt.show()

# 2. Box Plot of Apartment Prices
plt.figure(figsize=(6, 8))
sns.boxplot(y=merged_data['Median_price_2023'], color='lightblue')
plt.gca().yaxis.set_major_formatter(formatter)
plt.title("Box Plot of Apartment Prices")
plt.ylabel("Median Price 2023")
plt.show()

# 3. Scatter Plots with Linear Fit
fig, axes = plt.subplots(3, 1, figsize=(10, 18), sharey=True)

# Scatter Plot: Price vs Population Growth
sns.scatterplot(ax=axes[0], x='Historical_population_growth', y='Median_price_2023',
                data=merged_data, alpha=0.6)
sns.regplot(ax=axes[0], x='Historical_population_growth', y='Median_price_2023',
            data=merged_data, scatter=False, color='red', line_kws={"linewidth": 1})
axes[0].yaxis.set_major_formatter(formatter)
axes[0].set_title("Price vs Population Growth")
axes[0].set_xlabel("Historical Population Growth")
axes[0].set_ylabel("Median Price 2023")

# Scatter Plot: Price vs Median Income
sns.scatterplot(ax=axes[1], x='Historical_median_income', y='Median_price_2023',
                data=merged_data, alpha=0.6)
sns.regplot(ax=axes[1], x='Historical_median_income', y='Median_price_2023',
            data=merged_data, scatter=False, color='red', line_kws={"linewidth": 1})
axes[1].xaxis.set_major_formatter(formatter)
axes[1].yaxis.set_major_formatter(formatter)
axes[1].set_title("Price vs Median Income")
axes[1].set_xlabel("Historical Median Income")
axes[1].set_ylabel("Median Price 2023")

# Scatter Plot: Price vs Unemployment Rate
sns.scatterplot(ax=axes[2], x='Historical_unemployment_rate', y='Median_price_2023',
                data=merged_data, alpha=0.6)
sns.regplot(ax=axes[2], x='Historical_unemployment_rate', y='Median_price_2023',
            data=merged_data, scatter=False, color='red', line_kws={"linewidth": 1})
axes[2].yaxis.set_major_formatter(formatter)
axes[2].set_title("Price vs Unemployment Rate")
axes[2].set_xlabel("Historical Unemployment Rate")
axes[2].set_ylabel("Median Price 2023")

plt.tight_layout()
plt.show()

# Prepare data for modeling
model_data = merged_data[[
    'Median_price_2023', 'Historical_population_growth',
    'Historical_median_income', 'Historical_unemployment_rate',
    'Historical_priority_growth_area', 'Projected_population_growth',
    'Projected_median_income', 'Projected_unemployment_rate',
    'Projected_priority_growth_area'
]]

# Build linear regression model
model = smf.ols(
    formula='Median_price_2023 ~ Historical_population_growth + Historical_unemployment_rate + Historical_priority_growth_area',
    data=model_data
).fit()

# Print model summary
print(model.summary())

# Extract and print model coefficients
coef_summary = model.params
print("Model Coefficients:")
print(coef_summary)

# Define the independent variables and dependent variable
X = model_data[['Historical_population_growth', 'Historical_unemployment_rate', 'Historical_priority_growth_area']]
y = model_data['Median_price_2023']

# Add a constant to the independent variables (for the intercept)
X = sm.add_constant(X)

# Fit the GLM model
glm_model = sm.GLM(y, X, family=sm.families.Gaussian()).fit()

# Print model summary
print(glm_model.summary())

# Standardize coefficients
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X.iloc[:, 1:])  # Scaling the independent variables, excluding the constant

std_coef = glm_model.params[1:] * np.std(X_scaled, axis=0) / np.std(y)
print(std_coef)

# Get fitted values and residuals
fitted_values = glm_model.fittedvalues
residuals = glm_model.resid_response  # Correct way to get residuals

# Plot 1: Residuals vs Fitted Values
plt.figure(figsize=(14, 6))
plt.subplot(1, 2, 1)
sns.scatterplot(x=fitted_values, y=residuals)
plt.axhline(y=0, linestyle='--', color='red')
plt.title("Residuals vs Fitted Values")
plt.xlabel("Fitted Values")
plt.ylabel("Residuals")

# Plot 2: Q-Q Plot for Normality of Residuals
plt.subplot(1, 2, 2)
stats.probplot(residuals, dist="norm", plot=plt)
plt.title("Normal Q-Q Plot")
plt.xlabel("Theoretical Quantiles")
plt.ylabel("Sample Quantiles")

# Show the plots side by side
plt.tight_layout()
plt.show()

# Prepare future data
future_data = merged_data[['Suburb_name', 'Projected_population_growth', 'Projected_median_income',
                           'Projected_unemployment_rate', 'Projected_priority_growth_area']]

# Rename columns
future_data = future_data.rename(columns={
    'Projected_population_growth': 'Historical_population_growth',
    'Projected_median_income': 'Historical_median_income',
    'Projected_unemployment_rate': 'Historical_unemployment_rate',
    'Projected_priority_growth_area': 'Historical_priority_growth_area'
})

# Predict future prices using the model
future_prices = glm_model.predict(future_data[['Historical_population_growth',
                                              'Historical_median_income',
                                              'Historical_unemployment_rate',
                                              'Historical_priority_growth_area']])

# Optionally, add the predicted prices to the future_data DataFrame
future_data['Predicted_Median_Price_2023'] = future_prices

print(future_data[['Suburb_name', 'Predicted_Median_Price_2023']])

# Combine predictions with suburb names
predictions = pd.DataFrame({
    'Suburb': future_data['Suburb_name'],
    'Predicted_Price': future_prices
})

# Sort predictions in descending order of Predicted_Price
predictions = predictions.sort_values(by='Predicted_Price', ascending=False)

# Display top 10 highest median price suburbs
print(predictions.head(10))

# Get top 10 predicted prices
top_10_predictions = predictions.head(10)

# Create the bar plot
plt.figure(figsize=(10, 6))
sns.barplot(x='Predicted_Price', y='Suburb', data=top_10_predictions, palette='Reds')

# Customize the plot
plt.title("Top 10 Suburbs by Predicted Price")
plt.xlabel("Predicted Price")
plt.ylabel("Suburb")

# Format the y-axis for better readability
formatter = FuncFormatter(lambda x, _: f'{x:,.0f}')
plt.gca().yaxis.set_major_formatter(formatter)

# Show the plot
plt.tight_layout()
plt.show()

# Select relevant columns and rename them
future_data = merged_data[['Suburb_name', 'Projected_population_growth', 'Projected_median_income',
                           'Projected_unemployment_rate', 'Projected_priority_growth_area']]

# Rename the columns
future_data = future_data.rename(columns={
    'Projected_population_growth': 'Historical_population_growth',
    'Projected_median_income': 'Historical_median_income',
    'Projected_unemployment_rate': 'Historical_unemployment_rate',
    'Projected_priority_growth_area': 'Historical_priority_growth_area'
})

# The future_data DataFrame is now ready

# Predict future prices
future_prices = glm_model.predict(future_data[['Historical_population_growth',
                                              'Historical_median_income',
                                              'Historical_unemployment_rate',
                                              'Historical_priority_growth_area']])

# Add the predicted prices to the merged_data DataFrame
merged_data['Predicted_Price'] = future_prices

# Calculate the percentage increase
merged_data['Percentage_Increase'] = ((merged_data['Predicted_Price'] - merged_data['Median_price_2023'])
                                      / merged_data['Median_price_2023']) * 100

# Show the updated DataFrame
print(merged_data[['Suburb_name', 'Median_price_2023', 'Predicted_Price', 'Percentage_Increase']])

# Rank suburbs by percentage increase
top_suburbs = merged_data[['Suburb_name', 'Percentage_Increase']].sort_values(by='Percentage_Increase', ascending=False).head(10)

# Display top 10 suburbs by percentage increase
print(top_suburbs)

# Visualize top 10 suburbs by percentage increase
plt.figure(figsize=(10, 6))
sns.barplot(x='Percentage_Increase', y='Suburb_name', data=top_suburbs, palette='Blues_d')

# Customize the plot
plt.title("Top 10 Suburbs by Percentage Increase in Predicted Price")
plt.xlabel("Percentage Increase")
plt.ylabel("Suburb")

# Show the plot
plt.tight_layout()
plt.show()